/* vim:set ft=doxygen: */
/** @page edsevo EDS/Evolution

@dot
digraph G {
  labelloc = "t"
  labeljust = "l"

  node [
    shape = box
    style = filled
    color = white
    width = 1.5
  ]

  edge [
    fontsize = 11
    fontname = "Arial Narrow"
    arrowsize = 0.6
    //labeldistance = 8
    //labelfloat = true
  ]

  subgraph cluster_1 {
    style = filled
    color = "#bbbbff"
    label = "Evolution"

    ECal
    ECalListener

    ECalView
    ECalViewListener
  }

  subgraph cluster_2 {
    style = filled
    color = "#bbffbb"
    label = "EDS"

    EDataCal
    ECalBackend
    ECalBackendSync
    ECalBackend3e

    EDataCalView
  }

  // backend methods
  ECal -> EDataCal [ style = "dashed" color = "blue" ]

  EDataCal -> ECalBackend [ label = "calls from\ldiff. threads\l(per request)" ]

  ECalBackend -> ECalBackendSync
  ECalBackendSync -> EDataCal

  EDataCal -> ECalListener [ style = "dashed" color = "blue" label = "CORBA\loneway" ]

  ECalListener -> ECal [ label = "GObject\lsignals" ]

  ECalBackend -> ECalBackend3e [ color = "red" label = "\"async\"" ]
  ECalBackendSync -> ECalBackend3e [ label = "mutex\lprotected" ]

  ECalBackend3e -> ECalBackendSync
  ECalBackend3e -> EDataCal [ color = "red" ]

  // live query
  ECalViewListener -> ECalView [ label = "GObject\lsignals" ]
  ECalView -> EDataCalView [ style = "dashed" color = "blue" ]
  EDataCalView -> ECalViewListener [ style = "dashed" color = "blue" ]
  ECalBackend -> EDataCalView [ color = "yellow" label = "obj mod\lnotifications" ]
}
@enddot

@section Evolution

@subsection ECal ECal

Client interface to calendar backend. You may have multiple ECal objects
connected to the same backend instance.

ECal methods that comunicate with backend do so in following manner:
(ECalendarOp represents calendar operation and stores data returned from the
server, there can be only one ECalendarOp in progress at time)
- if there is ECalendarOp already in progress BUSY error is returned, otherwise new ECalendarOp is created 
- oneway CORBA call is sent to the server
- ECalendarOp condition is waited for
- ECalListener receives in separate thread CORBA call from the server
- ECalListener calls signal callback set up by the ECal
- signal callback updates current ECalendarOp with data returned from the server and signals ECalendarOp condition
- g_cond_wait in ECal method will return
- ECal method gets data/status from the ECalendarOp and frees ECalendarOp
- data/status is returned to the caller of the ECal method

ECal object may be used from multiple threads without external locking.

ECal uses EComponentListener to signal broken connection to the backend and
emits "backend_died" signal if connection is broken.

ECal also listens for mode changes from the backend and emits "cal_set_mode"
signal if mode is changed.

@b Initialization

- User calls e_cal_new(ESource* source),
- all factory objects that implement IDL:GNOME/Evolution/DataServer/CalFactory
  are activated
- for each factory getCal() methods is called
- first getCal() call that succeeds will return CORBA object representing
  calendar backend (this may be newly created object or already existing backend
  object, depending on whether given source is already opened by other ECal)
- ECal open method can be then called either synchronuously or asynchronuously
  from separate thread.
- open_calendar function will then call auth_function to get password if
  necessary
- after sucessful open signal is emitted in the main thread and load_state is
  set to E_CAL_LOAD_LOADED which enables user to call other ECal methods

TODO: possible refactoring should allow to try multiple passwords and call open
method repeatedly.

@subsection ECalListener

Receives oneway CORBA calls from backend and emits signals that are listened for
by ECal. Each ECal owns it's own listener. Each call is received in separate thread.

@subsection ECalView

ECal user may call e_cal_get_query() to start new live query that is represented
by the ECalView object on the client side.

This will create ECalView/ECalViewListener object pair that is similar to
already described ECal/ECalListener. ECalViewListener receives CORBA calls from
the backend and thransforms them into signals that are listened to by ECalView
object. Difference is that this calls are performed in the main thread.

Typical use case is to create ECalView for given sexp query, connect to five
ECalView signals 'objects_added', 'objects_modified', 'objects_removed',
'view_progress', 'view_done' and call e_cal_view_start().

Server will then perform initial match on the current contents of the whole
calendar and emit 'objects_added' notifications for all objects that match given
sexp query. After this initial load 'view_done' will be emitted to signal that
it's over. Should this operation take too long, backend may also emit
'view_progress' notifications with information about progress of the query.

For any later changes in the calendar 'objects_added', 'objects_modified',
'objects_removed' will be emitted.

Multiple ECalViews may exist at any given time.

@section EDS

@subsection EDataCalFactory

There is one EDataCalFactory object per EDS. This object stores activated
backends and implements IDL:GNOME/Evolution/DataServer/CalFactory interface
which has one method getCal() that is used to get existing or activate new
backend object for given source. 

If backend obejct for given uri/object type does not yet exist getCal() goes
through all registered backend factory methods (derived from ECalBackendFactory)
and finds one that matches given protocol/object type pair (for example
eee/VEVENT, protocol is extracted from the URI that is stored in the ESource
passed to the getCal()) and calls e_cal_backend_factory_new_backend() method to
create new backend.

Regardles of backend object already existed or must have been crated, new
EDataCal object is created and associated with ECalListener object on the client
side. This EDataCal object is then added to the list in the backend object.

BUG: why is listener duplicated in getCal() and EDataCal? isn't that leak?

@subsection EDataCal

EDataCal object is used to communicate with client. It implements
IDL:GNOME/Evolution/Calendar/Cal interface.

When constructing EDataCal object ECalBackend and
GNOME_Evolution_Calendar_CalListener objects are associated with it.

CORBA calls are proxied to the backend object. Backend methods can
possibly be called from multiple EDataCal objects at the same time (from
different threads).

NOTE: For understanding what happens on the server the most important is to find
entripoints. In case of EDS these are impl_Cal_ methods. We will also need
'escape' points, because EDS uses CORBA oneway calls. These are all present also
in the EDataCal object. See calls to the GNOME_Evolution_Calendar_CalListener_*() 
methods.

@subsection ECalBackend

Each calendar backend must be derived from ECalBackend and implement its virtual
methods.

ECalBackend methods are supposed to call e_data_cal_notify_*() methods to notify
client of the result of the operation. If they fail to do so, deadlock will
occur on the client side. For this reason EDataCal is passed to each method as
a second parameter.

Backend methods may also call e_cal_backend_notify_object_*() methods that will
go through existing live queries and if object matches any of them notifies 
the client that something happened to the object. It is not necessary to call
this for requested object operation. This should be only called when
non-requested change occurs.

ECalBackend also keeps track of live queries, see EDataCalView.

@subsection EDataCalView

There may be multiple EDataCalView objects per backend. These objects are used
to send notifications to ECalViewListener in the client if calendar object that
matches EDataCalView sexp expression is modified (created/modified/removed). 

This notification is done for all EDataCalViews associated with given backend
using e_cal_backend_notify_object_*() methods.

These methods are automatically called from EDataCal
e_data_cal_notify_object_*() methods and thus you only need to call them for
objects that changed independently from client's requests.

@subsection ECalBackendSync

Instead of deriving your backend from ECalBackend you can derive it from
ECalBackendSync, which has two advantages:
- you can assume that sync methods will be run sequentially,
- you don't need to call e_data_cal_notify_*() methods youself.

*/
