/* vim:set ft=doxygen: */
/** @page attadesign Attachments Design

@verbatim
Navrh implementace attachmentu
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Zakladni predpoklady:
- XML-RPC neni vhodne na prenaseni velkych bloku dat
- implementace libxr situaci jeste vice zhorsuje
- mit attachment primo v VEVENTU je neprakticke
- nechceme zbytecne tahat stejne prilohy kdyz to neni potreba

Rekneme ze mame 5MB attachment, jaka bude spotreba pameti na serveru pri
zpracovani pozadavku ktery ho bude obsahovat:

- samotne telo pozadavku ma 1.33x5MB base64 (pozadavek se cely nacte do
pameti)
- dale se zparsuje pomoci libxml2 do DOM stromu, to je dalsich 1.33x5MB 
- dale se strom prekonvertuje do objektu xr_call takze dalsich 1.33x5MB
(behem konverze se nyni dela jeste jedna kopie retezce, takze to je
dalsich 1.33x5MB, ale to by se dalo vyresit)
- nakonec se v metode zparsuje samotny VEVENT takze mame dalsi objekt
ktery jiz ale bude obsahovat dekodovanou reprezentaci attachmentu, takze
jen 1x5MB

Takze mame spickovou spotrebu pameti 5x5MB tj. 25MB a naprosto zbytecne
vytizeni site 1.33x vice nez je potreba. To omezuje maximalni velikost
priloh na (velikost RAM+swap serveru / 5).

Mit attachment primo v VEVENTU zakodovany jako base64 je taky
neprakticke z toho duvodu, ze treba v evolution se VEVENTy prevadeji na
retezec a prasuji zpet casto i nekolikrat behem jedne elementarni
operace a navic museji byt vzdy v RAM minimalne 2x (jako retezec a pak
dekodovane v icalcomponent obejktu). Cili jen pro operace s VEVNTEm
obsahujicim prilohy by jsme potrebovali 5x velkost prilohy RAM. 



Co jsme tedy vcera s Jurou vybrainstormovali :-) je tohle:

Serverova cast libxr je obycejny HTTP(S) server, takze proc neudelat
podporu pro HTTP POST s content-type: binary/wahtever a do servletu
pridat specialni metodu __upload__ ve ktere by se dal zpracovat prichozi
stream z HTTP POST a ulozit do souboru na serveru. Drumy smer by
obsatarala metoda __download__ ktera by slouzila pro zpracovani GET
pozadavku.

Co se tyce samotne implementace attachmentu, tak to by vypadalo takhle:
- attachment by byl jednoznacne identifikovan svym obsahem (sha1 obsahu,
jako v gitu)
- attachment by mel take stabilni uri, pomoci ktere by se na nej
odkazovalo z VEVENTu
- v VEVENTu by byl take v parametru lidsky nazev attachemntu

Uri attachmentu by vypadala tak jako dnes s jendou drobnou upravou:

eee://username@domain.net/file/0123456789abababababababababababababab
'username@' je volitelne


Cely proces prace s VEVENTem ktery ma prilohu by tedy vypadal takto:
- user naklika v evolution v meeting dialogu ze chce pridat prilohu
- backend plugin se nejak dozvi cesty k souborum a jejich nazvy a 
  pri synchronizaci vypocte sha1 jednotlivych souboru a zahaji POST
  pozadavek, v HTTP hlavicce uvede sha1 souboru
- na serveru se vytvori instance servletu a zavola se metoda __upload__,
  ktera:
  - volitelne se provede overeni uzivatele a hesla, ale pro zajisteni
    toho aby nikdo nemohl menit obsah cizich priloh to neni nutne
  - z hlavicky co poslal klient vytahne sha1 a zjsiti zda uz soubor
    se stejnym sha1 ve storagi na serveru je a prerusi upload pokud ano
  - pokud ne tak nastreamuje data do nejakeho docasneho souboru (takze
    misto 17x velikost souboru, bude spotreba pameti konstantni a to
    dana velikosti stream bufferu, treba 8kB a nebude omezena velikost
    priloh)
  - zaroven pri streamovani se vypocte sha1 obsahu a pokud souhlasi
    s tim co poslal klient tak se ulozi do finalniho souboru jehoz nazev
    bude obsahovat sha1 obsahu
- do VEVENTu se zapisi URI priloh a jejich nazvy
- vse ostatni bude fungovat tak jako ted, VEVENT se syncne na server a
  hotovo

Stahovani priloh by probihalo v backend pluginu takto:
- pri synchronizaci, pokud se narazi na VEVENT ktery obsahuje ATTACHMENT
  property s eee://domain.net/file/sha1, tak se uri atatchmentu prevede
  na URI ktere pouziva libxr (http://server:port/file/sha1) a provede se
  download
- pokud soubor se stejnou sha1 uz existuje v lokalni storagi
  attachmentu na klientovi, tak se samozrejme zadne stahovani dit nebude
- na serveru se vyvola metoda __download__ ktera zpracuje cestu v GET ze
  ktere vytahne sha1 pozadovaneho souboru a nastreamuje ho klientovi
- klient si overi sha1 a ulozi attachment do lokalni storage


Plus tam budou nejspis nejake transformace VEVENTu v tak aby mu rozumel
frontend evolutiony a mohl spravne zobrazit seznam priloh.

S iTipy by to fungovalo stejne s tim rozdilem, ze by prilohy server
automaticky pridal k vygenerovanemu mailu. Jinac by vse fungovalo tak
jak je popsane vyse. Napriklad bob@travel posila REQUEST na carl@reklam
v REQUESTu bude VEVENT ktery bude obsahovat ATTACHMENT s URI
eee://travel/file/12346586786768786768764231574 a MUA/CUA ktery pouziva
carl@reklam bude mit dve moznosti, bud si vytahnout prilohu z mailu,
nebo pozdeji potom co mail uz smazal, si muze otevrit meeting a CUA mu
prilohu stahne primo ze serveru travelu. Takze nedochazi ke zbytecnemu
prenaseni souboru pri meziserverove komunikaci a i presto ma carl@reklam
pristup k priloham REQUESTu.

Cely tenhle pristup ma docela dost vyhod, zvlaste v nasem systemu kde
umoznujem sdilet kalendare:
- pokud mame v CUA vice kalendaru s veventy se stejnou prilohou tak se
  stahuje jen jednou a pote se automaticky sdili mezi vsemi VEVENTy
- pokud uz byla priloha se stejnym obsahem nekdy uploadnuta na server
  neni ji treba uploadovat znova
- prilohy s velikosti nad 100MB nepolozi server
- neomezena velikost priloh
- je 100% zajistena integrita dat jak na serveru tak u klienta, pokud
  klient zjisti ze sha1 neodpovida obsahu muze se automaticky pokusit
  stahnout prilohu znova
- upload priloh muze byt klidne i bez prihlasovani aniz by to umoznilo
  treti strane zmenit obsah existujici prilohy (podvrhnout neco)
- download muze byt take bez autentizace (sha1 poslouzi jako dostatecne
  dlouhy nahodny retezec, na to aby se dal uhodnout) a umozni to ten
  usecase s iTipem vyse (carl stahuje primo z travelu jen kdyz
  potrebuje) 
  - jedina situace kdy se to da uhodnout je ze uz znas obsah souboru
    ktery chces stahnout :) - samozrejme se taky da sha1 nekde ukrast
    nekomu primo z kalendare a pak si ten soubor budes moc stahnout,
    ale pokud uz mas takovy pristup k nekomu do kalendare tak te nake
    prihlaseni stejne nezastavi

@endverbatim

*/
